#!/usr/bin/env bash

# Script to do renames, replaces, breaks for LTS point updates

# Copyright 2012 Canonical, Ltd.
# Author:  Bryce W. Harrington
# License: MIT license, same as X (see http://www.opensource.org/licenses/mit-license.php)
########################################################################
# The new stacks will be introduced alongside the stock 12.04 stack and
# will co-exist with them. All of the packages will be renamed to not
# conflict with the packages in the stock 12.04 stack. We will utilize
# mesa's alternatives system to install the updated GL libraries and
# enable them.
#
# Only the server-side components of the X stack will be upgraded, not
# libX11 or any other client-side code.
#
# For package naming, kernel names source packages by appending
# -lts-backports-$VERSION. They don't appear to need to rename binary
# packages since they already include the kernel version; instead I'm
# assuming we would rename binary packages like sources - append
# -lts-backports-$VERSION.
#
# The X.org packages will be renamed following the kernel convention
# ('linux-lts-backport-natty' c.f. bug #806586), to enable them to
# co-exist in the same archive. Thus, the X package names will have
# 'lts-backport-VERSION' appended to them:
#
#   mesa-lts-backport-quixotic
#   xserver-xorg-video-intel-lts-backport-quixotic
#   xserver-xorg-video-intel-dbg-lts-backport-quixotic
#   xorg-server-lts-backport-quixotic
#   xserver-xorg-core-dbg-lts-backport-quixotic
#   xserver-common-lts-backport-quixotic
#
########################################################################
# Copyright (C) 2012 Canonical, Ltd.
# Author:  Bryce W. Harrington
# License: MIT license, same as X
#          (see http://www.opensource.org/licenses/mit-license.php)
########################################################################

lts_codename=quantal
suffix=lts-backport-${lts_codename}
#codename=$(current-ubuntu-development-codename)
verbose=1

if [ "$0" = "$(basename "$0")" ]; then
    basedir="$(dirname $(readlink -e $(which "$0")))"
else
    basedir="$(dirname $(readlink -e "$0"))"
fi

usage() {
    echo "Usage:  $0 [-hqv] <mapping-file>"
    echo " -h:              This help text"
    echo " -q:              Quell output"
    echo " -v:              Extra verbose output"
}

ERR() {
    echo "Error: $*" 2>&1
    exit 1
}

warn() {
    echo "Error: $*" 2>&1
}

msg() {
    if [ $verbose -gt 0 ]; then
	echo "$*"
    fi
}

dbg() {
    if [ $verbose -gt 1 ]; then
	echo "$*"
    fi
}

base_version() {
    buf=${1#*:}          # Strip epoch
    echo ${buf%-*}       # Strip debian version
}

while getopts "h\?qv" opt $*; do
    case "$opt" in
	h ) usage 0                                ;;
	\?) usage 1                                ;;
	q ) verbose=0                              ;;
	v ) verbose=2                              ;;
	* ) warn "Unknown option '$opt'"; usage 1  ;;
    esac
done
shift `expr $OPTIND - 1`

rename_mapping_file=$1
if [ -z "${rename_mapping_file}" ]; then
    usage 1
elif [ ! -e "${rename_mapping_file}" ]; then
    ERR "No such file ${rename_mapping_file}"
fi

# Determine package name from the changelog
changelog=debian/changelog
if [ ! -e ${changelog} ]; then
    dbg $PWD
    ERR "Could not locate debian/changelog from the current dir"
fi

rules=debian/rules
if [ ! -e ${rules} ]; then
    dbg $PWD
    ERR "Could not locate debian/rules from the current dir"
fi

control=debian/control
if [ ! -e ${rules} ]; then
    msg $PWD
    ERR "Could not locate debian/control from the current dir"
fi

old_package=$(head -n 1 ${changelog} | cut -d' ' -f1)
old_package_version=$(head -n 1 ${changelog} | cut -d' ' -f2)
old_package_version=${old_package_version//[\(\)]/}  # Strip parens
new_package=${old_package}-${suffix}
base_version=$(base_version ${old_package_version})
old_binaries=$(grep ^Package: ${control} | cut -f2 -d' ')

if [[ "${old_package}" =~ ${suffix}$ ]]; then
    dbg ${old_package}
    ERR "Already renamed"
fi

msg "Renaming the orig.tar.gz..."
for ext in gz bz2 lzma xz; do
    old_orig="${old_package}_${base_version}.orig.tar.${ext}"
    new_orig="${new_package}_${base_version}.orig.tar.${ext}"
    if [ ! -e "../${old_orig}" ]; then continue; fi
    if [ -e "../${new_orig}" ]; then
        warn "../${new_orig} already exists so not renaming"
    else
        cp -via "../${old_orig}" "../${new_orig}"
        echo "${old_orig} -> ${new_orig}"
    fi
    msg
    break
done

msg "Updating the maintainer..."
update-maintainer -q
msg

msg "Adding a changelog entry..."
dch --increment \
    --package ${new_package} \
    --distribution ${lts_codename}-proposed \
    --force-distribution \
    "Rename package for the LTS point update, and add replaces/breaks"
msg

msg "Processing the control file..."
${basedir}/dpkg-control \
    --source-suffix ${suffix} \
    --binary-suffix ${suffix} \
    --mapping-file ${rename_mapping_file} \
    --add-replaces ${old_package} \
    --add-breaks "${old_package}=${old_package_version}" > ${control}.new
mv ${control}.new ${control}
msg

msg "Checking rules..."
grep ${old_package} ${rules}
if [ $? != 0 ]; then
    dbg "${rules} mentions ${old_package}"
    warn "Manual update of ${rules} required"
fi
msg

msg "Renaming binary install, etc. files..."
for pkg in ${old_binaries}; do
    msg "- Renaming ${pkg}.* files..."
    files=$(ls debian/${pkg}.*)
    if [ $? -ne 0 ]; then
	continue
    fi
    for old_file in $files; do
	dbg $old_file
	new_file=$(basename $old_file)
	new_file=debian/${new_file/${old_package}/${new_package}}
	msg "mv $old_file $new_file"
	mv $old_file $new_file
    # TODO: Maybe using 'rename' would be better?
    done
done
msg

msg "Generating changes file..."
debuild -S
msg

msg "${old_package} now renamed to ${new_package}"
