#!/usr/bin/env bash

# Script to do renames, replaces, breaks for LTS point updates

########################################################################
# The new stacks will be introduced alongside the stock 12.04 stack and
# will co-exist with them. All of the packages will be renamed to not
# conflict with the packages in the stock 12.04 stack. We will utilize
# mesa's alternatives system to install the updated GL libraries and
# enable them.
#
# Only the server-side components of the X stack will be upgraded, not
# libX11 or any other client-side code.
#
# For package naming, kernel names source packages by appending
# -lts-backports-$VERSION. They don't appear to need to rename binary
# packages since they already include the kernel version; instead I'm
# assuming we would rename binary packages like sources - append
# -lts-backports-$VERSION.
#
# The X.org packages will be renamed following the kernel convention
# ('linux-lts-backport-natty' c.f. bug #806586), to enable them to
# co-exist in the same archive. Thus, the X package names will have
# 'lts-backport-VERSION' appended to them:
#
#   mesa-lts-backport-quixotic
#   xserver-xorg-video-intel-lts-backport-quixotic
#   xserver-xorg-video-intel-dbg-lts-backport-quixotic
#   xorg-server-lts-backport-quixotic
#   xserver-xorg-core-dbg-lts-backport-quixotic
#   xserver-common-lts-backport-quixotic
#
########################################################################

lts_codename=quantal
suffix=lts-backport-${lts_codename}
#codename=$(current-ubuntu-development-codename)

usage() {
    echo "Usage:  $0 [-hqv] <mapping-file>"
    echo " -h:              This help text"
    echo " -q:              Quell output"
    echo " -v:              Extra verbose output"
}

while getopts "h\?qv" opt $*; do
    case "$opt" in
	h ) usage 0                                ;;
	\?) usage 1                                ;;
	q ) verbose=0                              ;;
	v ) verbose=2                              ;;
	* ) warn "Unknown option '$opt'"; usage 1  ;;
    esac
done
shift `expr $OPTIND - 1`

rename_mapping_file=$1
if [ -z "${rename_mapping_file}" ]; then
    usage 1
elif [ ! -e "${rename_mapping_file}" ]; then
    ERR "No such file ${rename_mapping_file}"
    exit 1
fi

ERR() {
    echo "Error: $*" 2>&1
}

msg() {
    if [ $verbose -gt 0 ]; then
	echo "$*"
    fi
}

dbg() {
    if [ $verbose -gt 1 ]; then
	echo "$*"
    fi
}

base_version() {
    buf=${1#*:}          # Strip epoch
    echo ${buf%-*}       # Strip debian version
}

# Determine package name from the changelog
changelog=debian/changelog
if [ ! -e ${changelog} ]; then
    echo $PWD
    echo "ERROR: Could not locate debian/changelog from the current dir"
    exit 1
fi

rules=debian/rules
if [ ! -e ${rules} ]; then
    echo $PWD
    echo "ERROR: Could not locate debian/rules from the current dir"
    exit 2
fi

control=debian/control
if [ ! -e ${rules} ]; then
    echo $PWD
    echo "ERROR: Could not locate debian/control from the current dir"
    exit 3
fi

old_package=$(head -n 1 ${changelog} | cut -d' ' -f1)
old_package_version=$(head -n 1 ${changelog} | cut -d' ' -f2)
old_package_version=${old_package_version//[\(\)/}  # Strip parens
new_package=${old_package}-${suffix}
base_version=$(base_version ${old_package_version})
old_binaries=$(grep ^Package: ${control} | cut -f2 -d' ')

if [[ "${old_package}" =~ ${suffix}$ ]]; then
    echo ${old_package}
    echo "ERROR: Already renamed"
    exit 3
fi

echo "Renaming the orig.tar.gz..."
old_orig=${old_package}_${base_version}.orig.tar.gz
new_orig=${new_package}_${base_version}.orig.tar.gz
if [ -e ../${new_orig} ]; then
    echo "Warning: ../${new_orig} already exists so not renaming"
else
    cp -via ../${old_orig} ../${new_orig}
fi
echo

echo "Updating the maintainer..."
update-maintainer -q
echo

echo "Adding a changelog entry..."
dch --increment \
    --package ${new_package} \
    --distribution ${lts_codename}-proposed \
    --force-distribution \
    "Rename package for the LTS point update, and add replaces/breaks"
echo

echo "Processing the control file..."
dpkg-control \
    --source-suffix ${suffix} \
    --binary-suffix ${suffix} \
    --mapping-file ${rename_mapping_file} \
    --add-replaces ${old_package} \
    --add-breaks "${old_package}=${old_package_version}" > ${control}.new
mv ${control}.new ${control}
echo

echo "Checking rules..."
grep ${old_package} ${rules}
if [ $? != 0 ]; then
    echo "${rules} mentions ${old_package}"
    echo "Warning: Manual update of ${rules} required"
fi
echo

echo "Renaming binary install, etc. files..."
for pkg in ${old_binaries}; do
    echo "- Renaming ${pkg}.* files..."
    files=$(ls debian/${pkg}.*)
    if [ $? -ne 0 ]; then
	continue
    fi
    for old_file in $files; do
	echo $old_file
	new_file=$(basename $old_file)
	new_file=debian/${new_file/${old_package}/${new_package}}
	echo "mv $old_file $new_file"
	mv $old_file $new_file
    # TODO: Maybe using 'rename' would be better?
    done
done
echo

echo "Generating changes file..."
debuild -S
echo

echo "${old_package} now renamed to ${new_package}"
