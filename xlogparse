#!/usr/bin/perl -w
#========================================================================
#
# xlogparse
#
# DESCRIPTION
#
# Parses Xlog.*.log format files and allows looking up data from it
#
# AUTHOR
#   Bryce W. Harrington <bryce@bryceharrington.org>
#
# COPYRIGHT
#   Copyright (C) 2007 Bryce W. Harrington
#   All Rights Reserved.
#
#   This program is free software; you can redistribute it and/or
#   modify it under the same terms as Perl itself.
#
#========================================================================

use strict;
use Pod::Usage;
use Getopt::Long qw(:config no_ignore_case bundling);

#------------------------------------------------------------------------
# Global variables
#------------------------------------------------------------------------
use vars qw($VERSION $NAME);
$VERSION              = '1.00';
$NAME                 = 'xlogparse';

our $opt_version      = 0;
our $opt_help         = 0;
our $opt_helplong     = 0;
our $opt_man          = 0;
our $opt_debug        = 1;
our $opt_errors       = 0;
our $opt_warnings     = 0;
our $opt_summary      = 0;
our $opt_devices      = 0;
our $opt_modules      = 0;

Getopt::Long::Configure ("bundling", "no_ignore_case");
GetOptions(
    "version|V",        # Prints the version and exits
    "help|h",           # Prints a brief help message
    "helplong|H",       # Prints a long help message
    "man|M",            # Prints a manual page (detailed help)
    "debug|D=i",        # Prints debug messages
    "summary",          # Prints a summary of the xorg log
    "devices",          # List configured drivers
    "errors",           # Lists errors present
    "warnings",         # List warnings present
    "modules",          # List loaded modules
    ) or pod2usage(-verbose => 0, -exitstatus => 0);

version_and_exit() if $opt_version;
pod2usage(-verbose => 0, -exitstatus => 0) if $opt_help;
pod2usage(-verbose => 1, -exitstatus => 0) if $opt_helplong;


#========================================================================
# Subroutines
#------------------------------------------------------------------------

=head2 version_and_exit()

Displays text describing the version of the script

=cut

sub version_and_exit
{
    print "$NAME version $VERSION\n";
    print "Copyright (C) 2007 Bryce W. Harrington <bryce\@bryceharrington.org>\n";
    print "This program is free software; you can redistribute it and/or\n";
    print "modify it under the same terms as Perl itself.\n";
    exit(0);
}


# Tool for parsing Xorg.*.log formatted files

sub process_record {
    my $content = shift || return undef;
    my %rec;
    chomp $content;

    $rec{line} = $content;

    if ($content =~ /^\((\w+)\)/) {
        $rec{type} = $1;
    } else {
        $rec{type} = 'XX';
    }

    if ($content =~ /XINPUT: Adding extended input device "(.*:?)" \(type:\s+(.*:?)\)/) {
        $rec{device}->{name}  = $1;
        $rec{device}->{class} = 'input';
        $rec{device}->{type}  = $2;
    }

    # Get module information
    if ($content =~ /^\(II\) Module (\w+):/) {
        $rec{module}->{name} = $1;
        if ($content =~ /vendor="(.*:?)"/m) {
            $rec{module}->{vendor} = $1;
        }
        if ($content =~ /module version = (.*)/) {
            $rec{module}->{version} = $1;
        }
        if ($content =~ /class: (.*)/) {
            $rec{module}->{class} = $1;
        }
        if ($content =~ /ABI class:\s+(.*:?), version\s+(.*:?)/) {
            $rec{module}->{abi_name} = $1;
            $rec{module}->{abi_version} = $2;
        }
    }

    return \%rec;
}

my @Log;

my $buffer = '';
foreach my $line (<>) {
    if ($line =~ m/^\(/) {
        if (defined $buffer) {
            push @Log, process_record($buffer);
            $buffer = '';
        }
    } elsif ($line =~ m/^AUDIT/) {
        next;
    }
    $buffer .= $line;
}
if (defined $buffer) {
    push @Log, process_record($buffer);
}


my $log_count = @Log;

my @info = grep { $_->{type} eq "II" } @Log;
my $info_count = @info;

my @notimpl = grep { $_->{type} eq "NI" } @Log;
my $notimpl_count = @notimpl;

my @notices = grep { $_->{type} eq "!!" } @Log;
my $notice_count = @notices;

my @errors = grep { $_->{type} eq "EE" } @Log;
my $error_count = @errors;

my @warnings = grep { $_->{type} eq "WW" } @Log;
my $warning_count = @warnings;

my @devices = grep { defined $_->{device} } @Log;
my $device_count = @devices;

my @modules = grep { defined $_->{module} } @Log;
my $module_count = @modules;

if ($opt_errors) {
    for my $err (@errors) {
        print $err->{line}, "\n";
    }
}

if ($opt_warnings) {
    for my $warn (@warnings) {
        print $warn->{line}, "\n";
    }
}

if ($opt_summary) {
    print "\n";
    print "Log contains $log_count entries\n";
    print "  - $info_count info messages\n";
    print "  - $error_count errors\n";
    print "  - $warning_count warnings\n";
    print "  - $device_count devices\n";
}

if ($opt_devices) {
    print "\n";
    print "Input Devices:\n";
    foreach my $device (@devices) {
        printf("  + %-12s %-20s %-s\n",
               $device->{device}->{class},
               $device->{device}->{name},
               $device->{device}->{type});
    }
}

if ($opt_modules) {
    if ($opt_summary) {
        print "\n";
        print "Modules:\n";
        printf("  + %-10s %-10s %-s\n",
               "MODULE", "VERSION", "VENDOR");
    } else {
        printf("%-10s %-10s %-30s %-s\n",
               "MODULE", "VERSION", "ABI-NAME", "VENDOR");
    }
    my $last_cat = '';
    foreach my $module (sort { $a->{module}->{abi_name} cmp $b->{module}->{abi_name} } @modules) {
        if ($opt_summary) {
            if ($module->{module}->{abi_name} ne $last_cat) {
                printf("\n %s\n", $module->{module}->{abi_name});
                $last_cat = $module->{module}->{abi_name};
            }
            printf("  + %-10s %-10s %-s\n",
                   $module->{module}->{name},
                   $module->{module}->{version},
                   $module->{module}->{vendor}
                   );
        } else {
            my $abi_name = $module->{module}->{abi_name};
            $abi_name =~ s/X.Org\s+//;
            $abi_name =~ s/\s/-/g;
            printf("%-10s %-10s %-30s %-s\n",
                   $module->{module}->{name},
                   $module->{module}->{version},
                   $abi_name,
                   $module->{module}->{vendor}
                   );
        }
    }
}




#########################################################################

__END__


=head1 NAME

B<xlogparse> - Parses Xlog.*.log format files and allows looking up data
from it


=head1 SYNOPSIS

treport [options] [ [ options ] ]

 Options:
   -V, --version=boolean         Prints the version and exits
   -h, --help=boolean            Prints a brief help message
   -H, --helplong=boolean        Prints a long help message
       --man=boolean             Prints a manual page (detailed help)
   -D, --debug=integer           Prints debug messages
       --summary                 Prints a summary of the log
       --devices                 Prints list of devices loaded
       --modules                 Prints list of modules loaded

=head1 DESCRIPTION

Parses Xlog.*.log format files and allows looking up data from it

=head1 OPTIONS

=over 8

=item B<-V>, B<--version>

Prints the version and exits

=item B<-h>, B<--help>

Prints a brief help message

=item B<-H>, B<--helplong>

Prints a long help message

=item B<--man>

Prints a manual page (detailed help)

=item B<-D> I<D>, B<--debug>=I<D>

Prints debug messages


=back

See B<xlogparse> -h for a summary of options.


=head1 PREREQUISITES

L<Pod::Usage>,
L<Getopt::Long>

=head1 BUGS

None known.

=head1 VERSION

1.00

=head1 SEE ALSO

L<perl(1)>


=head1 AUTHOR

Bryce W. Harrington E<lt>bryce@bryceharrington.orgE<gt>

L<http://www.bryceharrington.org|http://www.bryceharrington.org>

=head1 COPYRIGHT

Copyright (C) 2007 Bryce W. Harrington.
All Rights Reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 REVISION

Revision: $Revision: 1.1.1.1 $

=cut

